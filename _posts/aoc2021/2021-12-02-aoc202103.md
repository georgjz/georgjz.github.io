---
layout:     post
title:      "Advent of Code 2021, Day 3"
date:       2021-12-03
excerpt:    "For Advent of Code 2021 Day 3, we need to decode some binary data"
tags:       [Advent of Code 2021, Scheme, Programming]
feature:    /assets/img/punchcard.jpg
published:  true
comments:   true
---
# Advent of Code 2021, Day 3

Welcome to [Day 3][aoc03] of [Advent of Code 2021][aoc].

Our submarine adventure continues, we'll need to parse some binary data after we fixed the navigation computer [yesterday][day02].

I was lazy today, so only Scheme solution.

Without further ado, here we go.

## Scheme

### Part 1

Here's [the problem][aoc03] we need to solve: we need to parse a matrix of binary numbers.

```
00100
11110
10110
10111
10101
01111
00111
11100
10000
11001
00010
01010
```

You know the drill by now. We'll again first take care of the input. Since input is impure, we'll hide it away in a function:

```scheme
(define input
  (letrec ((input-file (open-input-file "Input.txt"))
          (R (lambda (ls)
               (let* ((dir (read input-file))
                      (val (read input-file))
                      (navcom (list dir val)))
                 (if (eof-object? dir)
                     ls
                     (R (cons navcom ls)))))))
    (reverse (R '()))))
```

This is almost identical to what we did [yesterday][day02]. We first read the direction into `dir`, and the value into `val`. Here's the potential for a subtle error: We use `let*` instead of `let` here. If we were to use `let`, the order of evaluation *would be reversed* - aka, `val` and `dir` would be switched. Since input operations are impure, order of evaluation matters, so be vary of that.

Next, we write a function that takes a *navigation command* and the *current position* and calculates the new position:

```scheme
(define move-simple
  (lambda (navcom curpos)
    (record-case navcom
      ((forward) (val) (list (+ (car curpos) val) (cadr curpos)))
      ((up)      (val) (list (car curpos) (- (cadr curpos) val)))
      ((down)    (val) (list (car curpos) (+ (cadr curpos) val)))
      (else (assertion-violationf 'navigate "invalid expression ~s" navcom)))))
```

We use Chez Scheme's [record-case](https://cisco.github.io/ChezScheme/csug9.5/control.html#./control:h0) to do a pattern matching-ish structure to interpret the given command to calculate the new position.

Next, we write a function that will navigate our submarine along the path of a *list of navigation* commands with a *move function*:

```scheme
(define navigate
  (lambda (move navcoms)
    (letrec ((N (lambda (navcoms curpos)
                  (if (null? navcoms)
                      curpos
                      (N (cdr navcoms) (move (car navcoms) curpos))))))
      (N navcoms '(0 0 0)))))
```

We enclose the starting position `(0 0 0)` inside `navigate`. The position is a 3-tuple here because we'll need it for part 2 below. This is so we can reuse all functions from part 1 in part 2, because we love function composition.

Finally, we write a solution function that calculates the final position from a given *navigation command list*:

```scheme
(define solution
  (lambda (movef navcoms)
    (let ((finalpos (navigate movef navcoms)))
      (* (car finalpos) (cadr finalpos)))))
```

`solution` applies a *move function* and a *list of navigation commands* to `navigate`. We then calculate the product of the horizontal position and the depth, which is the result for part 1. So we can now calculate the result for part 1 thus:

```scheme
(define solution-part1 (solution move-simple input))
```

```bash
$ scheme .\Dive_Bang.scm
Chez Scheme Version 9.5.5
Copyright 1984-2020 Cisco Systems, Inc.
> solution-part1
1815044
```

That's the correct result for [my input][input].

### Part 2

For part 2, we need to change the move function to include *aim* (which I interpret as the [submarine's pitch](https://www.researchgate.net/figure/The-six-degree-of-freedom-model-of-submarine_fig1_274622739)):

```scheme
(define move-aim
  (lambda (navcom curpos)
    (let ((horizontal (car curpos))
          (depth (cadr curpos))
          (aim (caddr curpos)))
      (record-case navcom
        ((forward) (val) (list (+ horizontal val) (+ depth (* aim val)) aim))
        ((up)      (val) (list horizontal depth (- aim val)))
        ((down)    (val) (list horizontal depth (+ aim val)))
        (else (assertion-violationf 'navigate "invalid expression ~s" navcom))))))
```

And now, we compose the functions from part 1 for our solution:

```scheme
(define solution-part2 (solution move-aim input))
```

```bash
$ scheme .\Dive_Bang.scm
Chez Scheme Version 9.5.5
Copyright 1984-2020 Cisco Systems, Inc.

> solution-part2
1739283308
```

This yields the correct answer of 1739283308 for [my input][input]. Find the complete solution [here][scms].

Awesome! Let's do it again in Haskell.

Again, the correct numbers [for my input][input].

That's it for today. You can find all my solutions on [my Github][gh].

See you tomorrow.


[aoc]: https://adventofcode.com/2021
[aoc01]: https://adventofcode.com/2021/day/1
[aoc02]: https://adventofcode.com/2021/day/2
[aoc03]: https://adventofcode.com/2021/day/3
[hask]: https://wiki.haskell.org/Haskell
[scm]: https://en.wikipedia.org/wiki/Scheme_(programming_language)
[chez]: https://cisco.github.io/ChezScheme/
[ghc]: https://www.haskell.org/ghc/
[gh]: https://github.com/georgjz/advent-of-code-2021
[input]: https://github.com/georgjz/advent-of-code-2021/blob/main/Day_03_Giant_Squid/Input.txt
[comp]: https://en.wikipedia.org/wiki/Function_composition_(computer_science)
[pure]: https://en.wikipedia.org/wiki/Pure_function
[scms]: https://github.com/georgjz/advent-of-code-2021/blob/main/Day_03_Giant_Squid/Giant_Squid.scm
[megaparsec]: https://hackage.haskell.org/package/megaparsec
[day02]: {% post_url aoc2021/2021-12-02-aoc202102%}
[day0w]: {% post_url aoc2021/2021-12-04-aoc202104%}