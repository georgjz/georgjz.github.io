---
layout:     post
title:      "Advent of Code 2019, Day 2"
date:       2019-12-02
excerpt:    "My not-so-great solutions for Advent of Code 2019 Day 2 in Haskell and Forth"
tags:       [Advent of Code 2019, Haskell, Forth, programming]
feature:    /assets/img/punchcard.jpg
published:  true
comments:   true
---
# Advent of Code 2019, Day 2

I'll have to admit two things today: I wasn't able to finish part 2 of today's challenge in Forth. And my Haskell solution for part 2 feels pretty hack-y and bruteforce-y.

Without further ado, here we go.

## Haskell 

I'm not super happy with this solution, I feel like revisiting this at a later point. I think the "program" that we need to run could be replace with one function composition.

### Part 1

Find the problem description for part 1 [here](https://adventofcode.com/2019/day/2).

The [input file][input] is a plain text file with each memory addresses' value on separated by commas. This makes it easy to write a parser. I'll use [Megaparsec][megaparsec] for writing a simple parser. 

Here's the parser code: 

```
-- Parser
type Parser = Parsec Void String
        
sc :: Parser ()
sc = L.space space1 empty empty
    
lexeme :: Parser a -> Parser a
lexeme = L.lexeme sc
        
integer :: Parser Integer
integer = lexeme L.decimal
    
program :: Parser [Integer]
program = integer `sepBy` char ','
```

It's almost the same parser I used for yesterday's challenge.

My idea for the solution is this. First, I "compile" the memory content into a program that I can then fold over the memory content:

```
-- Part 1
execute :: (Int, Int, Int, Int) -> [Int] -> [Int]
execute (opc, a, b, c) mem = m ++ r : mem'
  where 
    r = case opc of 1 -> mem !! a + mem !! b 
                    2 -> mem !! a * mem !! b 
    (m,_:mem') = splitAt c mem

compile :: [Int] -> [(Int, Int, Int, Int)]
compile (99:_) = [] 
compile (a:b:c:d:r) = (a,b,c,d) : compile r

executePrg:: [(Int, Int, Int, Int)] -> [Int] -> [Int]
executePrg prg mem = foldl (flip execute) mem prg
```

I think this could be further simplified with something along the lines of `compose = foldr (.) id` and thus composing the list of program commands to run into a single function to apply to memory. But I couldn't get it to work in reasonable time. 

```
main :: IO () 
main = do 
    input <- readFile "Input.txt"
    let (Right xs) = runParser program "" input
        prg        = compile xs
        resultP1   = head $ executePrg prg xs
    putStrLn $ "Result part 1: " ++ show resultP1
```

Should result in 3306701 if you use my [input file][input].

### Part 2

Part 2 asks use to replace the second and third element of the input file such that when running about program, the result returns as 19690720 (the date of the moon landing).

One could be tempted to solve this with tail recursion, but I find unfolding more elegant and concise:

```
fuelPerModuleFuel :: Integer -> [Integer]
fuelPerModuleFuel = 
    tail . unfoldr (\a -> if a <= 0 then Nothing else Just (a, next a)) 
  where  
    next = fuelPerModule 
```

Mind the `tail` call. This is to remove the original module mass which would otherwise be part of the list that will be summed up.

Next, we only need to `map`, `concat`, and `sum` this function again over the input list:

```
main :: IO () 
main = do 
    input <- readFile "Input.txt"
    let (Right xs) = runParser masses "" input
        resultP1   = sum . map fuelPerModule $ xs
        resultP2   = sum . concatMap fuelPerModuleFuel $ xs
    putStrLn $ "Result Part 1: " ++ show resultP1
    putStrLn $ "Result Part 2: " ++ show resultP2
```

This results in 5115927. You can check out the complete solution [here][solhask], this file also includes all the imports you'll need. 

Let's move on to Forth.

## Forth 

I'm going to solve both parts in one go here. My basic approach will be the same: Get all the inputs onto the stack, map a function over all inputs to get the correct result.

Here are the functions I'm going to use:

```
: fuelpermodule  ( u -- u )
    3 / 2 - ;

: addtoarray  ( u addr u -- )
    cells + ! ;

: arrayloop  ( addr -- )
    depth 1- 0 do 
        tuck  i addtoarray 
    loop drop ;

: map  ( xt addr len -- )
    0 do  2dup i cells + @ swap execute  -rot  loop 2drop ;

: sum  ( n n -- n )
    depth 1- 0 do + loop ;

: fuelpermodulefuel  ( u -- u )
    dup 0> if 
        dup fuelpermodule
        recurse  +
    else 
        drop 0
    then ;

```

No real surprises here. I'm going to use a variable called `values` to store the input array. Then, I'll use `map` and `sum` to calculate the result:

```
\ Part 1 
s" Input.f" included                    \ get input values to stack
depth constant len                      \ save number of inputs as constant
variable values  depth 1- cells  allot  \ create array for input values
values arrayloop                        \ save input values in array
' fuelpermodule values len map          \ map fuelpermodule function over array
sum                                     \ sum up all fuel
s" Solution to Part 1: " type . cr      \ print result

\ Part 2 -- input still stored in values 
:noname negate ; values len map  sum 
' fuelpermodulefuel values len map  sum 
s" Solution to Part 2: " type . cr      \ print result
bye 
```

Thanks to the input file's format, I don't need to write a parser for this, I can simple "run" the input file to put all values on stack.

This returns: 

```
Solution to Part 1: 3412531 
Solution to Part 2: 5115927 
```

Success! I'll admit it's not the most elegant solution, but it works. There's probably a shorter solution in using `recursve` for part 1 `fuelpermodule`. Then we wouldn't need to store the input in an array first...probably. Find the whole solution [here][solforth].

I'll be adding my solutions to two GitHub repositories:

- [Haskell solutions][ghhask]
- [Forth solutions][ghforth]

See you tomorrow.


[aoc]: https://adventofcode.com/2019
[hask]: https://wiki.haskell.org/Haskell
[forth]: https://en.wikipedia.org/wiki/Forth_(programming_language)
[gjz]: https://georgjz.github.io/posts/
[ghc]: https://www.haskell.org/ghc/
[ghhask]: https://github.com/georgjz/advent-of-code-2019-haskell
[solhask]: https://github.com/georgjz/advent-of-code-2019-haskell/blob/master/day01/Fuel.hs
[ghforth]: https://github.com/georgjz/advent-of-code-2019-forth
[solforth]: https://github.com/georgjz/advent-of-code-2019-forth/blob/master/day01/Fuel.f
[input]: https://github.com/georgjz/advent-of-code-2019-haskell/blob/master/day02/Input.txt
[megaparsec]: http://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html
[parsertutorial]: http://akashagrawal.me/beginners-guide-to-megaparsec/