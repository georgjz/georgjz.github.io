---
layout:     post
title:      "How to Write An Assembler in Haskell, Part 1"
date:       2018-12-21
excerpt:    "See how I start to design and write an assembler for the Motorola 6809 CPU family"
tags:       [programming, 6809, assembler, tutorial, Haskell]
feature:    /assets/snesaa/02/saa02_featurecard.gif
published:  false
comments:   true
---
# DRAFT

### Introduction
I've been toying with Haskell for a while now. Learning Haskell has completely changed my perspective on programming. I mostly did my programming in C and assembly when working with MCUs or embedded systems; and C++ for pretty much anything else.

Functional programming always sounded too arcane (and, frankly, useless) to ignorant teenager me, who, of course, only wanted to write games. Yet once I started ghci for the first time and typed in my first simple set comprehensions, I was immediately captured by Haskell. Especially since Haskell is also an excellent learning tool for more advanced mathematical topics like numerical methods or category theory. Or to implement numeric algorithms like Newton's Method for finding roots of polynoms. It eliminates some of the overhead other (procedural) programming languages produce for such implementations.

But I don't want to dwell too much on this. If you're into programming and haven't tried a functional programming language yet, I highly recommend you try Haskell. It's not fast or simple to pick up, but the changed perspective alone is worth the experience. You'll never look at a (programming) problem the same way again.

That being said, let's get to the real meat. My plan is to write a two-pass macro assembler for the Motorola 6809 CPU family.

### Assembly? Motorola 6809? Why?
The Motorola 6809 is a CPU originally developed by Motorola (d'uh). Among others, the 6809 was used in two of my favorite machines: The Dragon 32/64 and the Vectrex console. Writing code for old gaming consoles like the NES, Sega Genesis, or SNES is one of my hobbies. I've also started to write my own Vectrex game, yet I got stock for lack of a proper toolchain.

There are a few 6809 assemblers available on the web. Yet they all lack either certain features, or have some weird quirks that annoy me. I admit, that I'm probably absolutely spoiled by cc65, which is an excellent toolchain for 6502 and 65816 development I cannot recommend enough. If you're writing code for NES, SNES, C64, or any other 6502-based machine, look no further.

So, since no assembler offers me all the things I want, I thought to myself, "Hey, why not write your own? Could be a fun project". And so the idea was born: The Wyvern Assembler!

Why Wyvern? Dragon Assembler was already taken, so Wyvern it is.

### What I want from my assembler
Here's a basic list of features I want Wyvern to have:

* Two-pass assembler that supports labels, symbols, sections, and import and export of labels/symbols
* Assembler directives geared towards multi-file projects (think `#include` in C/C++)
* Support for macros
* Support for both the Motorola 6809 and Hitachi 6309
* The assembler produces linkable and relocatable object files the linker can combine into the final executable. The linker uses a configuration file to fit the target machine's memory map. (you may recognize this feature from cc65)

The last point is actually the most important. It pretty much sums up the other features. When working with larger projects, you'd normally want to write code in multiple files to keep things organized. Most assembler will actually translate code directly into machine code; larger projects are organized with some variant of `#include`, which will simple merge multiple files into one large file that the assembler translates.

This isn't optimal for various reasons. For example, simply merging all project files into one big file with `#include` directives would cause the assembler retranslate the entirety of the code, even if only one of the merged files changed.

This is only a quick-and-dirty overview of Wyvern. There's of course a lot of details to fill in. I'll explain what I mean by linkable or relocatable when we come to the actual implementation.

### So, Who Should Read This?
This series of blog post will be about designing and implementing a 6809 assembler in Haskell. I'll assume you're somewhat familiar with assembly programming on any platform. This is not a machine language programming tutorial. If you're familiar with terms like mnemonic and pseudo opcode, you should be fine to follow.

Also, I'll not dwell in long discussion of whether assembly programming in the year 2018 still makes sense, or why I don't use C or any other language. I love old gaming console, and I want to write games for them on modern machines with advanced features that let me handle larger-than-three-files projects easily. I'm going to do it in Haskell because I want to. Simple as that.

### The Roadmap
I've never written such a software project on my own. So here's the roadmap I want to use to guide the development of Wyvern. It is by no means the best or most effective way to tackle such a project. So don't take this for the One and True Way(TM).

1. Define the Abstract Syntax Tree of a 6809 assembly file. Use this for the parser.
2. Write a working parser for 6809 assembly files.
3. Implement the first pass of the assembler for translation into an intermediate file. Define a intermediate file format.
4. Implement the second pass of the assembler that will create the linkable object file. Define a object file format.
5. Implement the linker that will link multiply object files into the final executable.

I admit this is very rough and probably very lacking. But I see this as a learning projects, so mistakes are actually a good thing. Only mistakes force you to reevaluate and learn something new.


The rest of this post will be about solving point 1. This is basically a rephrasing of the question, "How does a valid source file look like?" What I want to do here is to use a EBNF-ish notation to define all elements the parser must be able to recognize and parse. This will be the focus of the following section.

### A Source Code Example
Here's a short example how a 6809 assembly source file might look like:

[example source]

Here you can see one important feature of a good assembler. The assembler not only translates the mnemonics and operands into the correct machine code the CPU understands and executes. You can also use so called assembler directives (sometimes called pseudo opcodes). Assembler directives offer additional functionality to the programmer beyond the simple translation of mnemonics into machine code (note, that the terms mnemonics, machine code, and opcode are often used interchangeably; this is not 100% correct, but I'll point out the differences when it matters).

Basically, the assembler turns a mnemonic and operand like `ldd $1a3b` into it's machine code equivalent `0xCC 0x1A 0x3B`. Assembler directives like `.include` or `.byte` let me define additional data in my source file for usage by the code.

Here are all the elements the parser needs to recognize:
