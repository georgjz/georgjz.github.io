---
layout:     post
title:      "SNES Assembly Adventure 05: Subroutines and Direct Memory Access"
date:       2018-11-06
excerpt:    "Improve your code from last time with new programming techniques"
tags:       [SNES Assembly Adventure, assembly, programming, SNES, tutorial]
feature:    /assets/snesaa/04/saa04_featurecard.png
published:  false
comments:   true
---
# DRAFT

Welcome back, Adventurer. In this article, I'll introduce you to subroutines and *Direct Memory Access*. You will learn

* What the stack is and how it works
* What subroutines are and how they work
* How Direct Memory Access works and how to utilize it
* How to improve the example from last time and make the sprite bounce of the screen boundaries

As I told you last time, the way we moved data to VRAM wasn't the most effective. We will revisit the sprite example from the last article, make it a bit more effective by utilizing DMA (Direct Memory Access) and make the sprite bounce off the screen boundaries. So this will also be your first lines of game logic code. Let's get started!

[title card]

But before we dive deeper into subroutines, we first need to introduce the *stack*. I'll probably come back to the stack several times in future articles, since it's such a great and important concept to understand. So this is by no way a complete description of the stack and all its functionality.

### The Stack
The stack, formally called a LIFO (last-in, first-out) structure, is a certain range of memory locations where we can store data. The most important characteristic of a stack being that it is a *chronological* structure. So whatever data we *pushed* last onto the stack, is the first data that gets *pulled* from the stack.

When we want to place data on the stack, we say we're **pushing** onto (the top) the stack; when we want to retrieve that data again from the stack, we say we're **pulling** data from (the top of) the stack (*Note*: Some processor architectures use *pop* instead of *pull*; popping and pulling from stack are the same, just different words for it).

Imagine a stack of plates: Whenever we *push* a plate on top of the stack, we first need to *pull* the last plate we put on top of the stack, before we can *pull* any of the plates beneath it:

[stack image]

Here is how the stack on the 65816 works. I'll first describe the operations in general, then I'll show you some code examples.

Whenever **we push data onto the stack**, the 65816 takes the value inside the internal *stack pointer* or SP and decrements it by either one, two, or three (we will see shortly why). Then it uses the new stack pointer (+1) as address to store the data in memory. I'll explain the '(+1)' in a moment.

Whenever **we pull data from the stack**, the 65816 loads the data from the address stored in the stack pointer (+1), then increments the stack pointer by either one, two, or three.

Here is what the '(+1)' part in the paragraphs above means: The stack pointer on a 65816 always points *one byte beyond* the data we last pushed onto the stack. For example, if the stack pointer currently holds the value `$1ffa` and we pull one byte from the stack, the data stored at address `$1ffb` (stack pointer + 1) will be pulled, and the stack pointer set to `$1ffb`.

Likewise, if we push two bytes onto the stack, the stack pointer will decrement by two from `$1ffa` to `$1ff8`, the two bytes we push onto the stack are then stored at the addresses `$1ff9` and `$1ffa` respectively.

Let's make this a bit more clearer with a simple code example. This code will also include code to switch the 65816 from emulation to native mode, set the index registers X and Y to 16-bit, while the accumulator will operate in 8-bit mode.

[ stack code ]

[Detailed code description]


### Subroutines
If you're familiar with any programming language, you have most probably heard of *functions* (sometimes also called *procedures*). Functions are one of the most fundamental units of any programming language. It helps us to abstract our program and reuse code.

When programming in 65816 machine language, we call these programming units *subroutines* instead of functions. But they are (more or less) the same thing.

When we call a subroutine in our code the following will happen: The 65816 will push the *program counter* or PC onto the stack (this is the *return address* where execution will resume after the subroutine is done). Then it will jump to the subroutine and continue execution from there. Once the subroutine is done, we tell the CPU to return to where it left off before by pulling the return address we pushed onto the stack earlier back into the PC.

[subroutine graphic]

Let's write a simple example. We want to write a simple subroutine called `AddXtoY`. This subroutine will execute a 16-bit addition: It will add the value in the register X to the value in register Y (and store it in Y).

As always, I'll first show you the code, then discuss it in detail.

[subroutine code]
